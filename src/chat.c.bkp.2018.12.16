#include "stdio.h"
#include "stdlib.h"
#include "chat.h"
#include "strtok.h"
#include "version.h"
#include "gpio.h"
#include "memory.h"
#include "ad779x.h"


#define PROMPT	"> "

char data[SECTOR_SIZE];

enum {
	CMD_HELP = 0,
	CMD_VER,
	CMD_DATE,
	CMD_GPIO,
	CMD_MSR,
        CMD_FLASHTEST,
        CMD_ADCTEST,
	CMD_SendDataToSTM,
	CMD_SendDataToX86,
	CMD_trx,
	CMD_LAST
};

char *cmd_list[CMD_LAST] = {
	"help",
	"ver",
	"date",
	"gpio",
	"measure",
        "TestFlash",
	"TestADC",
	"SendDataToSTM",
	"SendDataToX86",
	"trx",
};

void vChatTask(void *vpars)
{
	char s[64];
	char cmd[64];
	char *c;
	char *tk;
	int i = 0;
	int adc_ret = -1;

	gpio_init();

	while (1) {
		cdc_write_buf(&cdc_out, PROMPT, sizeof(PROMPT) - 1, 1);
		memset(cmd, 0, sizeof(cmd));
		c = cmd;

		while (1) {
			i = cdc_read_buf(&cdc_in, c, 1);
			if (i)
				cdc_write_buf(&cdc_out, c, 1, 1);
			else {
				vTaskDelay(10);
				continue;
			}
			if (*c == '\r') {
				cdc_write_buf(&cdc_out, "\n", 1, 1);
				break;
			}
			if (*c == 8) { /* backspace */
				*c = 0;
				if (c > cmd)
					c -= 1;
				continue;
			}
			if (c + 1 < cmd + sizeof(cmd))
				c += 1;
		};

		sniprintf(s, sizeof(s), "OK\r\n");
		tk = _strtok(cmd, " \n\r");

		if (strcmp(tk, cmd_list[CMD_VER]) == 0) {
			sniprintf(s, sizeof(s), "%s\r\n", __VERSION);

		} else if (strcmp(tk, cmd_list[CMD_HELP]) == 0) {
			int i;

			for (i = 0; i < CMD_LAST; i++) {
				char *_s = cmd_list[i];

				cdc_write_buf(&cdc_out, _s, strlen(_s), 1);
				cdc_write_buf(&cdc_out, "\r\n", 2, 1);
			}

		} else if (strcmp(tk, cmd_list[CMD_DATE]) == 0) {
			sniprintf(s, sizeof(s), "%d\r\n", xTaskGetTickCount());

		} else if (strcmp(tk, cmd_list[CMD_GPIO]) == 0) {
			int i = 0, v;

			tk = _strtok(NULL, " \n\r");
			if (tk)
				i = atoi(tk);
			tk = _strtok(NULL, " \n\r");
			if (tk) {
				unsigned int timeout = 1000;

				v = !!atoi(tk);

				tk = _strtok(NULL, " \n\r");
				if (tk)
					timeout = atoi(tk);
				if (!timeout)
					timeout = 1000;

				gpio_set_val_timeout(i, v, timeout);
			} else {
				v = gpio_out_get(i);
			}
			sniprintf(s, sizeof(s), "%d: %d\r\n", i, v);
		} else if (strcmp(tk, cmd_list[CMD_SendDataToSTM]) == 0) {
			int i,j,k; 
			int sz = -1, rsz = 0;
			uint32_t address;
			// data receive from the host
			tk = _strtok(NULL, " \n\r");
			if (!tk) {
				cdc_write_buf(&cdc_out, "Err1\r\n", 0, 1);
				sniprintf(s, sizeof(s), "");
				goto out;
			}
			sz = atoi(tk); // size of the upcoming data package in bytes
			// address to write in
			tk = _strtok(NULL, " \n\r");
			if (!tk) {
				cdc_write_buf(&cdc_out, "Err1\r\n", 0, 1);
				sniprintf(s, sizeof(s), "");
				goto out;
			}
			address = strtol(tk, NULL, 16); // it must points at the sector begining!!! like this XXX000 or XXXXX000
			sFLASH_Init();
			//sniprintf(s, sizeof(s), "%d - %d - %d\r\n", sz/USB_TRX_SIZE, sz%USB_TRX_SIZE, sz/USB_TRX_SIZE + (sz%USB_TRX_SIZE != 0));
			//cdc_write_buf(&cdc_out, s, 0, 1);
			// the data writing
			for (i = 0; i < sz/PAGE_SIZE + (sz%PAGE_SIZE != 0); i++) {
				// erasing if in the sector begining
				if ((address & 0x00000FFF) == 0) {
					//sniprintf(s, sizeof(s), "address: %x erased\r\n", address);
					//cdc_write_buf(&cdc_out, s, 0, 1);
					//sFLASH_EraseSector(address, 1);  //!!!!!
				}
				cdc_write_buf(&cdc_out, "ready\r\n", 0, 1);
				while ((rsz < PAGE_SIZE) & ((rsz < sz%PAGE_SIZE) | (sz%PAGE_SIZE == 0))) {
					//int tmp = cdc_read_buf(&cdc_in, &data[rsz], USB_TRX_SIZE); 
					//rsz += tmp;
					//if (tmp != 0) {
					//	sniprintf(s, sizeof(s), "%d ", rsz);
					//	cdc_write_buf(&cdc_out, s, 0, 1);
					//}
					rsz += cdc_read_buf(&cdc_in, &data[rsz], PAGE_SIZE);
				}
				//sniprintf(s, sizeof(s), "received: %d\r\n", rsz);
				//cdc_write_buf(&cdc_out, s, 0, 1);
				//cdc_write_buf(&cdc_out, "data: ", 0, 1);
				//for (k = 0; k < rsz; k++) {
				//	sniprintf(s, sizeof(s), " %x", data[k]);
				//	cdc_write_buf(&cdc_out, s, 0, 1);
				//}
				//sniprintf(s, sizeof(s), "\r\naddress: %x written\r\n", address);
				//cdc_write_buf(&cdc_out, s, 0, 1);
				//sniprintf(s, sizeof(s), "\r\n");
				//sFLASH_WriteData(data, address, rsz, 1); //!!!!
				address += USB_TRX_SIZE;
				rsz = 0;
			}
			sFLASH_DeInit();
		} else if (strcmp(tk, cmd_list[CMD_SendDataToX86]) == 0) {
			int i = 0, j = 0, t1, t2;
			int sz = 0, rsz = 0, prnt = 0; 
			//char rpl, data[PAGE_SIZE];
			char rpl;
			uint32_t address;

			tk = _strtok(NULL, " \n\r");
			if (!tk) {
				cdc_write_buf(&cdc_out, "Err1\r\n", 0, 1);
				sniprintf(s, sizeof(s), "");
				goto out;
			}
			sz = atoi(tk); // amount of data to send to the host, bytes
			// address to read from
			tk = _strtok(NULL, " \n\r");
			if (!tk) {
				cdc_write_buf(&cdc_out, "Err1\r\n", 0, 1);
				sniprintf(s, sizeof(s), "");
				goto out;
			}
			address = strtol(tk, NULL, 16);
			sFLASH_Init();
			//sniprintf(s, sizeof(s), "i: %d\r\n", sz/PAGE_SIZE + (sz%PAGE_SIZE != 0));
			//cdc_write_buf(&cdc_out, s, 0, 1);
			//for (i = 0; i < sz/PAGE_SIZE + (sz%PAGE_SIZE != 0); i++) {
			while (i < sz/USB_TRX_SIZE + (sz%USB_TRX_SIZE != 0)) {
				prnt = USB_TRX_SIZE*(i < sz/USB_TRX_SIZE) + sz%USB_TRX_SIZE*(i == sz/USB_TRX_SIZE);
				//sniprintf(s, sizeof(s), "i: %d; d: %d\r\n", i, prnt);
				//cdc_write_buf(&cdc_out, s, 0, 1);
				//t1 = xTaskGetTickCount();
				sFLASH_ReadData(data, address, prnt, 1);
				//t2 = xTaskGetTickCount();
				//sniprintf(s, sizeof(s), "read: %d\r\n", t2-t1);
				//cdc_write_buf(&cdc_out, s, 0, 1);

				//t1 = xTaskGetTickCount();
				for (j = 0; j < prnt; j++) {
					sniprintf(s, sizeof(s), "%2x", data[j]);
					cdc_write_buf(&cdc_out, s, 0, 1);
					//cdc_write_buf(&cdc_out, &data[j], 16, 1);
				}
				cdc_write_buf(&cdc_out, "\r\n", 0, 1);
				//t2 = xTaskGetTickCount();
				//sniprintf(s, sizeof(s), "print: %d\r\n", t2-t1);
				//cdc_write_buf(&cdc_out, s, 0, 1);
				
				
				while ((rsz < 1) & (prnt == USB_TRX_SIZE))
					rsz = cdc_read_buf(&cdc_in, &rpl, 1);
				//sniprintf(s, sizeof(s), "%x\r\n", rpl);
				//cdc_write_buf(&cdc_out, s, 0, 1);
				//if (rpl == 1) {
				if (1) {
					address += USB_TRX_SIZE;
					i++;
				}
				//address += PAGE_SIZE;
				
				rsz = 0;
			}
			sFLASH_DeInit();
			//cdc_write_buf(&cdc_out, "\r\n", 0, 1);
			sniprintf(s, sizeof(s), "");
		} else if (strcmp(tk, cmd_list[CMD_ADCTEST]) == 0) {
			uint8_t i,j,k,ID, SR, MD = 0x20, FS = 0x0D;
			uint16_t MR, CR;
			uint32_t wtf = 0x200D, OFF1, OFF2, OFF3, DD[25];
			int data, v[10], V, VVV;
			float D,d[25],DDD;

			AD_Init();

			ID = AD_ReadID();
			SR = AD_ReadStatus();
			MR = AD_ReadMode();
			CR = AD_ReadConfig();
			//sniprintf(s, sizeof(s), "INIT: ID: %x, SR: %x, MR: %x, CR: %x\r\n", ID, SR, MR, CR);
			//cdc_write_buf(&cdc_out, s, strlen(s), 1);
			
			AD_SetConfig(AD_CR_BM | AD_CR_Gain128 | AD_CR_RD | AD_CR_BUF | AD_CR_CH2);

			//ID = AD_ReadID();
			//SR = AD_ReadStatus();
			//MR = AD_ReadMode();
			//CR = AD_ReadConfig();
			//sniprintf(s, sizeof(s), "CONFIGURED: ID: %x, SR: %x, MR: %x, CR: %x\r\n", ID, SR, MR, CR);
			//cdc_write_buf(&cdc_out, s, strlen(s), 1);
			
			//AD_ReadDataCont(DD,25,AD_MR_FS_123);

			//ID = AD_ReadID();
			//SR = AD_ReadStatus();
			//MR = AD_ReadMode();
			//CR = AD_ReadConfig();
			//sniprintf(s, sizeof(s), "AFTER CONT READ: ID: %x, SR: %x, MR: %x, CR: %x\r\ndata:\r\n", ID, SR, MR, CR);
			//cdc_write_buf(&cdc_out, s, strlen(s), 1);

			/*
			for (i = 0; i < 25; i++) {
				d[i] = DD[i];
				D = (3200000000.0/0x800000)*(d[i]-0x800000)/128.0;
				V = D;
				sniprintf(s, sizeof(s), "%x - %d\r\n", DD[i], V);
				sniprintf(s, sizeof(s), "%d\r\n", V);
				cdc_write_buf(&cdc_out, s, strlen(s), 1);
			}
			*/

			//V = mean(d);
			//sniprintf(s, sizeof(s), "%d\r\n", V);
			//cdc_write_buf(&cdc_out, s, strlen(s), 1);


			int SIZE = sizeof(d)/4;
			for (j=0; j < 10; j++) {
				AD_ReadDataCont(DD,SIZE,AD_MR_FS_123);
				D = 0;
				for (i = 0; i < SIZE; i++) {
			                D += (1200000000.0/8388608.0)*(DD[i]-8388608.0)/128.0;
			                //D += (1200000000.0/8388608.0)*(AD_ReadDataSingle(AD_MR_FS_19)-8388608.0)/128.0;
				}
				
				V = D/SIZE;	
				sniprintf(s, sizeof(s), "%d, ", V);
				cdc_write_buf(&cdc_out, s, strlen(s), 1);
			}		

			/*						
			AD_SetMode(AD_MR_MD_IZC | AD_MR_FS_4);
			AD_SetMode(AD_MR_MD_IFC | AD_MR_FS_4);
			for (i = 0; i < 3; i++) {
				//AD_SetMode(AD_MR_MD_IZC | AD_MR_FS_4);
				//AD_SetMode(AD_MR_MD_SC | AD_MR_FS_4);
				AD_SetMode(AD_MR_MD_SC | AD_MR_FS_4);
				data = AD_ReadDataSingle();
				ID = AD_ReadID();
				SR = AD_ReadStatus();
				MR = AD_ReadMode();
				CR = AD_ReadConfig();
				sniprintf(s, sizeof(s), "AFTER SINGLE READ: ID: %x, SR: %x, MR: %x, CR: %x\r\n", ID, SR, MR, CR);
				cdc_write_buf(&cdc_out, s, strlen(s), 1);

				D = (3200000000.0/0x800000)*(data-0x800000)/32.0;
				v[i] = D;
				sniprintf(s, sizeof(s), "%d\r\n", v[i]);
				cdc_write_buf(&cdc_out, s, strlen(s), 1);
			}
			*/

			//cdc_write_buf(&cdc_out, s, strlen(s), 1);
			//sniprintf(s, sizeof(s), "%x\r\n", (SR & 0x80));
			//cdc_write_buf(&cdc_out, s, strlen(s), 1);
			//if (SR & 0x80) {
			//	sniprintf(s, sizeof(s), "JOPA\r\n");
			//	cdc_write_buf(&cdc_out, s, strlen(s), 1);
			//}
			//for (i = 0; i < 1; i++) {
			//	AD_SetMode(AD_MR_MD_SC | AD_MR_FS_4);
			//	data = AD_ReadDataSingle();
			//	D = (3200000.0/0x800000)*(data-0x800000)/32.0;
			//	v[i] = D;
			//	sniprintf(s, sizeof(s), "data read: %x\r\n", data);
			//	cdc_write_buf(&cdc_out, s, strlen(s), 1);
			//	sniprintf(s, sizeof(s), "data read: %d\r\n", data-0x800000);
			//	cdc_write_buf(&cdc_out, s, strlen(s), 1);
			//	sniprintf(s, sizeof(s), "data read: %d\r\n", v[i]);
			//	cdc_write_buf(&cdc_out, s, strlen(s), 1);
			//}

			AD_DeInit();
			sniprintf(s, sizeof(s), "");

		} else if (strcmp(tk, cmd_list[CMD_FLASHTEST]) == 0) {
			char DUMMY_BYTE = 0xA5;
			uint32_t ID = 0;
			sFLASH_Init();
			ID  = sFLASH_ReadID();
			sFLASH_DeInit();
			sniprintf(s, sizeof(s), "ID: %x\r\n", ID);
			cdc_write_buf(&cdc_out, s, strlen(s), 1);
		} else if (strcmp(tk, cmd_list[CMD_MSR]) == 0) {
			uint8_t i,j, SIZE = 25, VV[4], VVV[4];
			uint32_t D[25];
			int V[3];
			float fV;
			

			AD_Init();
			for (i = 0; i < 5; i++) {			
	  			AD_SetConfig(AD_CR_BM | AD_CR_Gain128 | AD_CR_RD | AD_CR_BUF | AD_CR_CH1);
				AD_ReadDataCont(D, SIZE, AD_MR_FS_123);
				fV = 0;
				for (j = 0; j < SIZE; j++) {
			                fV += (1200000000.0/8388608.0)*(D[i]-8388608.0)/128.0;
				}
				V[0] = fV/SIZE;
				mean(D,VV);

	  			AD_SetConfig(AD_CR_BM | AD_CR_Gain128 | AD_CR_RD | AD_CR_BUF | AD_CR_CH2);
				AD_ReadDataCont(D, SIZE, AD_MR_FS_123);

				fV = 0;
				for (j = 0; j < SIZE; j++) {
			                fV += (1200000000.0/8388608.0)*(D[i]-8388608.0)/128.0;
				}
				V[1] = fV/SIZE;

	  			AD_SetConfig(AD_CR_BM | AD_CR_Gain128 | AD_CR_RD | AD_CR_BUF | AD_CR_CH3);
				AD_ReadDataCont(D, SIZE, AD_MR_FS_123);
				fV = 0;
				for (j = 0; j < SIZE; j++) {
			                fV += (1200000000.0/8388608.0)*(D[i]-8388608.0)/128.0;
				}
				V[2] = fV/SIZE;
				

				sniprintf(s, sizeof(s), "CH0: %8x/%8d, ", V[0], V[0]);
				cdc_write_buf(&cdc_out, s, strlen(s), 1);
				sniprintf(s, sizeof(s), "CH1: %8x/%8d, ", V[1], V[1]);
				cdc_write_buf(&cdc_out, s, strlen(s), 1);
				sniprintf(s, sizeof(s), "CH2: %8x/%8d; \r\n", V[2], V[2]);
				cdc_write_buf(&cdc_out, s, strlen(s), 1);
				sniprintf(s, sizeof(s), "QQQ: %2x%2x%2x%2x; \r\n", VV[0],VV[1],VV[2],VV[3]);
				cdc_write_buf(&cdc_out, s, strlen(s), 1);

			}
			AD_DeInit();

			//VV[0] = 0xAA;
			//VV[1] = 0xBB;
			//VV[2] = 0xCC;
			//VV[3] = 0xDD;
			/*
			sFLASH_Init();
			sFLASH_EraseSector(0x00A000, 1);
			sFLASH_WriteData(VV, 0x00A000, sizeof(VV), 1);
			sFLASH_DeInit();

			sFLASH_Init();
			sFLASH_ReadData(VVV, 0x00A000, sizeof(VVV), 1);
			sFLASH_DeInit();

			sniprintf(s, sizeof(s), "READ: ");
			cdc_write_buf(&cdc_out, s, strlen(s), 1);
			for (i = 0; i < 4; i++) {
				sniprintf(s, sizeof(s), "%2x", VVV[i]);
				cdc_write_buf(&cdc_out, s, 0, 1);
			}
			*/	
			cdc_write_buf(&cdc_out, "\r\n", 0, 1);

					//sniprintf(s, sizeof(s), "result: %8x\r\n", VV);
			//cdc_write_buf(&cdc_out, s, strlen(s), 1);
	 		//ID  = sFLASH_ReadID();
			//sniprintf(s, sizeof(s), "ID: %x\r\n", ID);
			//cdc_write_buf(&cdc_out, s, strlen(s), 1);
		} else if (strcmp(tk, cmd_list[CMD_trx]) == 0) {
			uint16_t sz = 0, sd = 0, rd = 0;
			uint32_t address;
			// amount of data to send to the host, bytes
			tk = _strtok(NULL, " \n\r");
			if (!tk) {
				cdc_write_buf(&cdc_out, "Err1\r\n", 0, 1);
				sniprintf(s, sizeof(s), "");
				goto out;
			}
			sz = atoi(tk); 
			// address to read from
			tk = _strtok(NULL, " \n\r");
			if (!tk) {
				cdc_write_buf(&cdc_out, "Err2\r\n", 0, 1);
				sniprintf(s, sizeof(s), "");
				goto out;
			}
			address = strtol(tk, NULL, 16);
			sFLASH_Init();
			while (sd < sz) {
				// number of bytes to read from FLASH
				rd = SECTOR_SIZE*(sd/SECTOR_SIZE < sz/SECTOR_SIZE) + sz%SECTOR_SIZE*(sd/SECTOR_SIZE == sz/SECTOR_SIZE);
				//sniprintf(s, sizeof(s), "sz: %d; sd: %d; rd %d\r\n", sz, sd, rd);
				//cdc_write_buf(&cdc_out, s, 0, 1);
				// read data from FLASH to the data bufer
				sFLASH_ReadData(data, address, rd, 1);
				// write the data to the USB IO bufer
				sd += cdc_write_buf(&cdc_out, data, rd, 1);
				//cdc_write_buf(&cdc_out, "\r\n", 0, 1);
				// increment the address 
				address += SECTOR_SIZE;
			}
			sFLASH_DeInit();
			sniprintf(s, sizeof(s), "");
		} else
			sniprintf(s, sizeof(s), "E: try `help`\r\n");
out:
		cdc_write_buf(&cdc_out, s, strlen(s), 1);
	}
}

